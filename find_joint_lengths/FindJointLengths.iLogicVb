' iLogic code to find parts that are touching each other by analyzing geometric proximity
' This code checks distances between part surfaces and edges

Sub Main()
    Dim doc As AssemblyDocument = ThisApplication.ActiveDocument
    Dim asmDef As AssemblyComponentDefinition = doc.ComponentDefinition
	
	
    ' Tolerance for considering parts as "touching"
    Dim touchTolerance As Double = 0.15 ' Adjust this value as needed (in inches)
    Dim minJointLength As Double = 0.5  ' Minimum length to consider a joint valid (in inches)
    Dim unitLength As Double = 2.54     ' Conversion factor from cm to inches (1 inch = 2.54 cm)
    
	' Dictionary to store contact pairs and contact lengths
    Dim contactLengths As New Dictionary(Of String, Double)
	
    MessageBox.Show("Analyzing part geometry for proximity..." & vbCrLf & "This may take a moment for large assemblies.", "Progress")
    
    ' Get all component occurrences
	Dim Components As List(Of ComponentOccurrence) = GetAllLeafOccurrences(asmDef.Occurrences)

    ' Compare each part with every other part
    For i As Integer = 0 To Components.Count - 2
        For j As Integer = i + 1 To Components.Count - 1
            Try
                Dim comp1 As ComponentOccurrence = components(i)
                Dim comp2 As ComponentOccurrence = components(j)
                
                Dim name1 As String = GetComponentName(comp1)
                Dim name2 As String = GetComponentName(comp2)
                
                ' Check if parts are touching using bounding box proximity first (faster)
                If AreBoundingBoxesClose(comp1, comp2, touchTolerance) Then
    
				    Dim jointLength As Double = GetContactLengthBetweenParts(comp1, comp2, touchTolerance)
				    
				    ' Store pair key sorted alphabetically to avoid duplicates
				    If jointLength >= minJointLength Then
						Dim pairKey As String
					    If String.Compare(name1, name2) < 0 Then
					        pairKey = name1 & "," & name2
					    Else
					        pairKey = name2 & "," & name1
					    End If
					    
					    If Not contactLengths.ContainsKey(pairKey) Then
					        contactLengths.Add(pairKey, jointLength)
					    End If
					End If
                End If
                
            Catch ex As Exception
                ' Continue with next pair if there is an error
                Continue For
            End Try
        Next
    Next

	Try
        Dim docNameNoExt As String = System.IO.Path.GetFileNameWithoutExtension(doc.FullDocumentName)
        Dim csvPath As String = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(doc.FullFileName), docNameNoExt & "_JointPairs_" & DateTime.Now.ToString("yyyyMMdd_HHmmss") & ".csv")
	    Dim csvContent As New System.Text.StringBuilder()
	    
	    csvContent.AppendLine("Part A,Part B,Joint Length Inches")
	    
	    For Each pairKey As String In contactLengths.Keys
	        Dim parts() As String = pairKey.Split(","c)
	        Dim lengthVal As Double = contactLengths(pairKey)
	        csvContent.AppendLine(parts(0) & "," & parts(1) & "," & lengthVal.ToString("F3"))
	    Next
	    
	    System.IO.File.WriteAllText(csvPath, csvContent.ToString())
	    MessageBox.Show("Touching part list with contact lengths exported to:" & vbCrLf & csvPath, "Export Complete")
	
	Catch ex As Exception
	    MessageBox.Show("Failed to write CSV file: " & ex.Message, "Export Error")
	End Try
End Sub

' Function to check if bounding boxes are close (quick preliminary check)
Function AreBoundingBoxesClose(comp1 As ComponentOccurrence, comp2 As ComponentOccurrence, tolerance As Double) As Boolean
    Try
        ' Convert tolerance from document units to desired units
        tolerance = tolerance * unitLength

        Dim box1 As Box = comp1.RangeBox
        Dim box2 As Box = comp2.RangeBox
        
        ' Check if bounding boxes overlap or are within tolerance
        Dim xOverlap As Boolean = (box1.MinPoint.X - tolerance <= box2.MaxPoint.X) And (box2.MinPoint.X - tolerance <= box1.MaxPoint.X)
        Dim yOverlap As Boolean = (box1.MinPoint.Y - tolerance <= box2.MaxPoint.Y) And (box2.MinPoint.Y - tolerance <= box1.MaxPoint.Y)
        Dim zOverlap As Boolean = (box1.MinPoint.Z - tolerance <= box2.MaxPoint.Z) And (box2.MinPoint.Z - tolerance <= box1.MaxPoint.Z)
        
        Return xOverlap And yOverlap And zOverlap
        
    Catch
        Return False
    End Try
End Function

Function GetContactLengthBetweenParts(comp1 As ComponentOccurrence, comp2 As ComponentOccurrence, tolerance As Double) As Double
    Try
        Dim maxContactLength As Double = 0.0
        tolerance = tolerance * unitLength

        For Each body1 As SurfaceBody In comp1.SurfaceBodies
            For Each face1 As Face In body1.Faces
                Dim bbox1 As Box = face1.Evaluator.RangeBox

                For Each body2 As SurfaceBody In comp2.SurfaceBodies
                    For Each face2 As Face In body2.Faces
                        Dim bbox2 As Box = face2.Evaluator.RangeBox

                        If face1.SurfaceType = SurfaceTypeEnum.kPlaneSurface AndAlso face2.SurfaceType = SurfaceTypeEnum.kPlaneSurface Then
                            Dim xLen As Double = Math.Min(bbox1.MaxPoint.X, bbox2.MaxPoint.X) - Math.Max(bbox1.MinPoint.X, bbox2.MinPoint.X)
                            Dim yLen As Double = Math.Min(bbox1.MaxPoint.Y, bbox2.MaxPoint.Y) - Math.Max(bbox1.MinPoint.Y, bbox2.MinPoint.Y)
                            Dim zLen As Double = Math.Min(bbox1.MaxPoint.Z, bbox2.MaxPoint.Z) - Math.Max(bbox1.MinPoint.Z, bbox2.MinPoint.Z)

                            If xLen >= -tolerance AndAlso yLen >= -tolerance AndAlso zLen >= -tolerance Then
                                Dim candidateLength As Double = Math.Max(xLen, Math.Max(yLen, zLen))
                                If candidateLength > maxContactLength Then
                                    maxContactLength = candidateLength
                                End If
                            End If
                        End If
                    Next
                Next
            Next
        Next

        ' Convert length from document units to desired units
        Return maxContactLength / unitLength

    Catch
        Return 0.0
    End Try
End Function

' Helper function to get specific component instance name
Function GetComponentName(comp As ComponentOccurrence) As String
    If comp Is Nothing Then Return "Unknown"
    
    Try
        ' Use the full name which includes the instance identifier (e.g., "Part_1:1", "Part_1:2")
        Dim fullName As String = comp.Name
        
        If Not String.IsNullOrEmpty(fullName) Then
            Return fullName
        End If
        
        ' Fallback: try to construct name from definition + occurrence
        Try
            Dim baseName As String = System.IO.Path.GetFileNameWithoutExtension(comp.Definition.Document.DisplayName)
            ' Try to get instance number if available
            For i As Integer = 1 To comp.Parent.Occurrences.Count
                If comp.Parent.Occurrences.Item(i) Is comp Then
                    Return baseName & ":" & i.ToString()
                End If
            Next
            Return baseName & ":?"
        Catch
            Return fullName
        End Try
        
    Catch ex As Exception
        Return "Unknown_Instance"
    End Try
End Function

' Recursively get all leaf parts (non-assembly components)
Function GetAllLeafOccurrences(occurrences As ComponentOccurrences) As List(Of ComponentOccurrence)
    Dim allParts As New List(Of ComponentOccurrence)

    For Each occ As ComponentOccurrence In occurrences
        If occ.DefinitionDocumentType = DocumentTypeEnum.kAssemblyDocumentObject Then
            ' Recurse into subassembly
            Dim subAsmDef As AssemblyComponentDefinition = CType(occ.Definition, AssemblyComponentDefinition)
            Dim subParts As List(Of ComponentOccurrence) = GetAllLeafOccurrences(subAsmDef.Occurrences)
            
            For Each subOcc As ComponentOccurrence In subParts
                allParts.Add(subOcc)
            Next
        Else
            ' Add part
            If occ.Visible And Not occ.Suppressed Then
                allParts.Add(occ)
            End If
        End If
    Next

    Return allParts
End Function